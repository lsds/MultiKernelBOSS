#pragma once

#include "BossConnectorSplit.h"
#include "velox/connectors/Connector.h"
#include "velox/exec/tests/utils/PlanBuilder.h"

using namespace facebook::velox;
using namespace facebook::velox::connector;
using namespace facebook::velox::memory;
using namespace facebook::velox::exec::test;

namespace boss::engines::velox {

// TPC-H column handle only needs the column name (all columns are generated in
// the same way).
class BossColumnHandle : public ColumnHandle {
public:
  explicit BossColumnHandle(std::string const& name) : name_(name) {}

  std::string const& name() const { return name_; }

private:
  std::string const name_;
};

// TPC-H table handle uses the underlying enum to describe the target table.
class BossTableHandle : public ConnectorTableHandle {
public:
  explicit BossTableHandle(std::string const& connectorId, std::string&& tableName,
                           RowTypePtr&& bossTableSchema, std::vector<RowVectorPtr>&& rowDataVec,
                           std::vector<size_t>&& bossSpanRowCountVec)
      : ConnectorTableHandle(connectorId), tableName_(std::move(tableName)),
        tableSchema_(std::move(bossTableSchema)), rowDataVec_(std::move(rowDataVec)),
        spanRowCountVec_(std::move(bossSpanRowCountVec)) {}

  ~BossTableHandle() override {}

  std::string toString() const override;

  std::string const& getTable() const& { return tableName_; }

  RowTypePtr getTableSchema() const& { return tableSchema_; }

  std::vector<RowVectorPtr> const& getRowDataVec() const { return rowDataVec_; }

  std::vector<size_t> const& getSpanRowCountVec() const { return spanRowCountVec_; }

private:
  std::string tableName_;
  RowTypePtr tableSchema_;
  std::vector<RowVectorPtr> rowDataVec_;
  std::vector<size_t> spanRowCountVec_;
};

class BossDataSource : public DataSource {
public:
  BossDataSource(std::shared_ptr<RowType const> const& outputType,
                 std::shared_ptr<connector::ConnectorTableHandle> const& tableHandle,
                 std::unordered_map<std::string, std::shared_ptr<connector::ColumnHandle>> const&
                     columnHandles,
                 memory::MemoryPool* FOLLY_NONNULL pool);

  void addSplit(std::shared_ptr<ConnectorSplit> split) override;

  void addDynamicFilter(column_index_t /*outputChannel*/,
                        std::shared_ptr<common::Filter> const& /*filter*/) override {
    VELOX_NYI("Dynamic filters not supported by BossConnector.");
  }

  std::optional<RowVectorPtr> next(uint64_t size, ContinueFuture& future) override;

  uint64_t getCompletedRows() override { return completedRows_; }

  uint64_t getCompletedBytes() override { return completedBytes_; }

  std::unordered_map<std::string, RuntimeCounter> runtimeStats() override {
    // TODO: Which stats do we want to expose here?
    return {};
  }

private:
  RowVectorPtr getBossData(uint64_t length);

  RowTypePtr const& outputType_;
  std::shared_ptr<BossTableHandle> bossTableHandle_;
  std::string const& bossTableName_;
  std::vector<RowVectorPtr> const& bossRowDataVec_;
  std::vector<size_t> const& bossSpanRowCountVec_;

  // Mapping between output columns and their indices (column_index_t) in the datasets.
  std::vector<column_index_t> outputColumnMappings_;

  std::shared_ptr<BossConnectorSplit> currentSplit_;

  // First (splitOffset_) and last (splitEnd_) row number that should be
  // generated by this split.
  uint64_t splitOffset_{0};
  uint64_t splitEnd_{0};
  size_t spanCountIdx_{0};

  size_t completedRows_{0};
  size_t completedBytes_{0};

  memory::MemoryPool* FOLLY_NONNULL pool_;
};

class BossConnector final : public Connector {
public:
  BossConnector(std::string const& id, std::shared_ptr<const Config> properties,
                folly::Executor* FOLLY_NULLABLE /*executor*/)
      : Connector(id) {}

  std::unique_ptr<DataSource>
  createDataSource(std::shared_ptr<const RowType> const& outputType,
                   std::shared_ptr<connector::ConnectorTableHandle> const& tableHandle,
                   std::unordered_map<std::string, std::shared_ptr<connector::ColumnHandle>> const&
                       columnHandles,
                   ConnectorQueryCtx* FOLLY_NONNULL connectorQueryCtx) override final {
    return std::make_unique<BossDataSource>(outputType, tableHandle, columnHandles,
                                            connectorQueryCtx->memoryPool());
  }

  std::unique_ptr<DataSink>
  createDataSink(RowTypePtr /*inputType*/,
                 std::shared_ptr<ConnectorInsertTableHandle> /*connectorInsertTableHandle*/,
                 ConnectorQueryCtx* /*connectorQueryCtx*/,
                 CommitStrategy /*commitStrategy*/) override final {
    VELOX_NYI("BossConnector does not support data sink.");
  }
};

class BossConnectorFactory : public ConnectorFactory {
public:
  static constexpr char const* FOLLY_NONNULL kBossConnectorName{"boss"};

  BossConnectorFactory() : ConnectorFactory(kBossConnectorName) {}

  explicit BossConnectorFactory(char const* FOLLY_NONNULL connectorName)
      : ConnectorFactory(connectorName) {}

  std::shared_ptr<Connector>
  newConnector(std::string const& id, std::shared_ptr<Config const> properties,
               folly::Executor* FOLLY_NULLABLE executor = nullptr) override {
    return std::make_shared<BossConnector>(id, properties, executor);
  }
};

} // namespace boss::engines::velox